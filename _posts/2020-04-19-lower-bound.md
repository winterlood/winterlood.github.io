---
layout: post
title:  "정렬의 하계"
date:   2020-04-19 13:03:36 +0530
categories: Algorithm DataStructure
---

비교 정렬 알고리즘의 하한 그리고 의사결정나무에 대하여,


## 비교 정렬 알고리즘의 하한

정렬에는 여러가지 종류가 있다.

- 삽입 정렬
- 선택 정렬
- 버블 정렬
- 병합 정렬
- 퀵 정렬

이러한 정렬들은 단순 데이터의 크기를 비교하여, 
수행하게 되는데, 이러한 정렬 방식을 **Comparison sort**라고 한다.

이러한 정렬 방식의 수행 시간 T에 대하여 **T >= nlogn** 이라는 한계를 가지고 있는데,
> 아무리 빨리 해도, nlogn 보다 빠르게 수행될 수 는 없다는 뜻 이다.

왜 그렇게 되는것인지 알아보도록 하자.

## 의사 결정 나무 (Decision Tree)

![](/assets/post/decisiontree.png)
> 의사 결정 나무의 그림이다.

비교를 하여 정렬하는 알고리즘은 추상적인 관점에서,
모두다 결정 트리의 결과물로 볼 수가 있다.

이러한 결정트리는 주어진 입력에 대해, 
특정 알고리즘이 수행하는 **원소의 비교**를 표현하는
Full Binary Tree가 된다.

위 의사 결정트리의 그림을 보면, 
ABC 세 개의 원소사이의 비교를 통하여, 
가능한 모든 순서를 Leaf 노드에 나열해 놓았다

결국 ABC 이렇게 3개의 원소를 정렬해야 할 때,
다음 의사결정 나무를 따르게 되면 6개의 정렬결과가 나오게 된다
> Leaf노드는 정렬의 결과이다.

고로 우리가 여기서 알 수 있는것은 n개의 원소를 갖는 의사결정 나무의 Leaf 노드의 개수는 n! 개 
라는 것이다.

그렇다면 결국 정렬 알고리즘의 실행은
루트에서 부터, 하나의 리프까지 경로를 따라가는 것과 같다.

즉, 루트부터 가장 먼 Leaf 까지의 경로의 길이가 곧 최악의 경우 비교연산의 회수 라는 것이다.

**결과적으로, 최악의 경우 비교횟수는 Tree의 Height와 같게 된다.**


## 증명

아까도 말했듯이 n개를 비교하는 의사결정나무는 n!개의 leaf 노드를 보유한다.
> n개에 대한 모든 permutation을 생각해 보라

그리고 트리의 높이를 h라고 하자, 이 때 최대 리프의 개수는 2^h가 된다
즉, 도달 가능한 Leaf가 L개인 의사 결정트리에서는 다음 식이 성힙한다.

~~~
n! <= L <= 2^h
~~~

양변에 log연산을 하면,

~~~
log2(n!) < h
~~~
이므로,

스털링 근사에 따라,
h >= n * log (n) 이 된다.


## 또 다른 증명

여기서는 사전 지식이 필요하다
Tree의 노드를 두가지로 분류할 것이다.
Leaf 노드는 External 노드 즉 단말 노드라고 할 것이고,
그렇지 않은 모든 노드를 Internal 노드 즉 비 단말 노드라고 할 것이다.

비교, 중복되지 않는 좋은 알고리즘의 트리 모양은 Binary Tree가 될 것이고,

External Node의 개수는 아까도 말했듯이 Permutation인 n!이 된다.
> External Node == Leaf Node

이 경우에, 우리가 알고 싶은건 이 의사결정 나무의 최악의 경우인데,

결국 최악의 경우라는건 Root에서부터 가장 먼 External Node를 찾는 것이다.
> 가장 많이 비교를 하게 되는 과정을 찾는다는 말과 같다.

External Node의 개수를 m이라고 하자,

가장 깊은 External Node의 Level이 곧, 비교연산의 최악의 회수가 될 것이다.

h의 높이를 갖는 Full Binary Tree의 External Node의 개수는 

2^h가 되므로, 

~~~
m <= 2^h
~~~

위 수식을 만족하게 된다.

또한, Full Bianry Tree의 높이 h는 
~~~
h >= log2(m)
~~~
위 수식을 만족하게 되고, 

m = n! 이므로,
> External Node == Leaf Node

~~~
h >= log2(n!)
~~~
위 수식을 만족하게 되는 것이다.

